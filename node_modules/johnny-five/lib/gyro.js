var Board = require("../lib/board.js"),
  events = require("events"),
  util = require("util"),
  __ = require("../lib/fn.js"),
  sum = __.sum;

var priv = new Map();
var axes = ["x", "y"];

// TODO: Migrate to multi-device design

function Gyro(opts) {
  if (!(this instanceof Gyro)) {
    return new Gyro(opts);
  }

  var err = null;
  var isCalibrated = false;
  var sampleSize = 100;
  var sampleTime = 10;
  var time = 0;

  // For a 10 bit microprocessor:
  // 1500(Â°/s) / 1024 = 1.46 deg/s

  // 4.88mV / (0.167mV/dps * 2)
  // 0.67 = 4X
  // 0.167 = 1X
  // TODO: Parameterize this value
  var sensitivity = 14633;
  // Voltage
  // TODO: Parameterize this value?
  var VCC = 4.88;
  var K;

  var state = {
    // ROLL
    x: {
      angle: 0,
      value: 0,
      lastValue: 0,
      lastRate: 0,
      calibration: [],
      stash: [0, 0, 0, 0, 0],
      zeroVoltage: 503
    },
    // PITCH
    y: {
      angle: 0,
      value: 0,
      lastValue: 0,
      lastRate: 0,
      calibration: [],
      stash: [0, 0, 0, 0, 0],
      zeroVoltage: 503
    }
  };

  // Initialize a Device instance on a Board
  Board.Device.call(
    this, opts = Board.Options(opts)
  );

  // if (!opts.amplify ||
  //   (opts.amplify && opts.amplify !== 1 || opts.amplify !== 4)) {
  //   opts.amplify = 1;
  // }

  // if (opts.sensitivity && opts.sensitivity === Gyro.TK_4X) {
  //   sensitivity /= 4;
  // }

  K = opts.sensitivity * 10000;

  this.mode = this.io.MODES.ANALOG;

  this.pins.forEach(function(pin, index) {
    this.io.pinMode(pin, this.mode);
    this.io.analogRead(pin, function(data) {
      var sensor = state[axes[index]];
      var now = Date.now();
      var axis, combined;

      // Capture the previous ADC reading
      sensor.lastValue = sensor.value;

      // sensor.stash.shift();
      // sensor.stash.push(data);
      // sensor.value = (sum(sensor.stash) / sensor.stash.length);
      // sensor.value = (sensor.lastValue + data) / 2;
      // sensor.value |= 0;

      sensor.value = data;

      if (!isCalibrated &&
        (state.x.calibration.length === sampleSize &&
          state.y.calibration.length === sampleSize)) {

        isCalibrated = true;

        state.x.zeroVoltage = (sum(state.x.calibration) / sampleSize) | 0;
        state.y.zeroVoltage = (sum(state.y.calibration) / sampleSize) | 0;

        state.x.calibration.length = 0;
        state.y.calibration.length = 0;
      } else {
        if (sensor.calibration.length < sampleSize) {
          sensor.calibration.push(data);
        }
      }

      var threshold = 3;

      if (isCalibrated) {
        // Recalculate every 10ms

        if (now - time > sampleTime) {
          time = now;

          for (var i = 0; i < axes.length; i++) {
            axis = axes[i];

            // if (this.rate[axis] <= threshold && this.rate[axis] >= -threshold) {

            // }
            combined = state[axis].lastRate + this.rate[axis];

            state[axis].angle += (combined * sampleTime) / 2000;
            state[axis].lastRate = this.rate[axis];

            if (state[axis].angle < 0) {
              state[axis].angle += 360;
            } else {
              if (state[axis].angle > 359) {
                state[axis].angle -= 360;
              }
            }
          }
        }

        // state.x.angle += this.rate.x / 200;
        // state.y.angle += this.rate.y / 200;





        this.emit("data", {
          x: this.x,
          y: this.y
        });

        if (sensor.lastValue !== sensor.value) {
          this.emit("change", {
            x: this.x,
            y: this.y
          });
        }
      }
    }.bind(this));
  }, this);

  priv.set(this, state);

  Object.defineProperties(this, {
    isCalibrated: {
      get: function() {
        return isCalibrated;
      },
      set: function(value) {
        if (typeof value === "boolean") {
          isCalibrated = value;
        }
      }
    },
    pitch: {
      get: function() {
        return {
          rate: this.rate.y,
          angle: state.y.angle
        };
      }
    },
    roll: {
      get: function() {
        return {
          rate: this.rate.x,
          angle: state.x.angle
        };
      }
    },
    x: {
      get: function() {
        return state.x.value;
      }
    },
    y: {
      get: function() {
        return state.y.value;
      }
    },
    rate: {
      get: function() {
        return {
          // Divide by 1000 to scale voltage
          x: (((state.x.value - state.x.zeroVoltage) * K) / 1000) | 0,
          y: (((state.y.value - state.y.zeroVoltage) * K) / 1000) | 0
        };
      }
    }
  });
}

Object.defineProperties(Gyro, {
  TK_4X: {
    value: 0.59
  },
  TK_1X: {
    value: 0.146
  }
});


util.inherits(Gyro, events.EventEmitter);

Gyro.prototype.recalibrate = function() {
  this.isCalibrated = false;
};

module.exports = Gyro;
